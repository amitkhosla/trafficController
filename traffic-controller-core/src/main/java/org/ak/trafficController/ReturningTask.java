package org.ak.trafficController;

import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import org.ak.trafficController.pool.ObjectPoolManager;

/**
 * Returning task which will run and return some value which can be picked by next task.
 * @author amit.khosla
 *
 * @param <T> Type of the Returning task - the type of output it will generate
 */
public class ReturningTask<T> extends Task {

	/**
	 * Return returning task from pool or create and set the required values.
	 * @param unique Unique id
	 * @param supplier Supplier
	 * @param taskType task type
	 * @param <T> Supplier type
	 * @return
	 */
	static <K> ReturningTask<K> getFromPool(int unique, SupplierWhichCanThrowException<K> supplier, TaskType taskType) {
		ReturningTask<K> et = ObjectPoolManager.getInstance().getFromPool(ReturningTask.class, ()->new ReturningTask<K>(unique, supplier, taskType));
		et.uniqueNumber = unique;
		et.supplier = supplier;
		et.taskType = taskType;
		et.startingTask = et;
		return et;
	}
	
	@Override
	public boolean canSendBackToPool() {
		return false;
	}
	
	private SupplierWhichCanThrowException<T> supplier;
	private T output;

	/**
	 * Returning task constructor.
	 * @param unique Unique id
	 * @param supplier Supplier
	 * @param taskType Task type
	 */
	public ReturningTask(int unique, SupplierWhichCanThrowException<T> supplier, TaskType taskType) {
		super(unique, taskType);
		this.supplier = supplier;
	}
	
	/**
	 * Creates next task which will consume the value generated by this task.
	 * @param consumer Consumer of the type this task will generate
	 * @return Executable task which will run the consumer
	 */
	public ExecutableTask thenConsume(Consumer<T> consumer) {
		ExecutableTask t = thenConsume(consumer, TaskType.NORMAL);
		return t;
	}
	
	/**
	 * Creates a task which will work on the output generated by this task and have multiple consumers work in parallel
	 * @param consumers Consumer which will work on this data in parallel
	 * @return ParallelExecutingTask
	 */
	public ParallelExecutingTask thenConsumeMultiple(Consumer<T>... consumers) {
		AtomicBoolean retrieved = new AtomicBoolean(false);
		AtomicReference<T> data = new AtomicReference<>(null);
		RunnableToBeExecuted[] runnables = new RunnableToBeExecuted[consumers.length];
		for (int i=0;i<consumers.length; i++) {
			Consumer<T> consumer = consumers[i];
			runnables[i] = ()-> {
					if (!retrieved.get()) {
						synchronized (retrieved) {
							if (!retrieved.get()) {	
								T val = this.get();
								data.set(val);
								retrieved.set(true);
							}
						}
					}
					consumer.accept(data.get());
			};
		}
		ParallelExecutingTask<T> parallelTask = ParallelExecutingTask.getFromPool(this.uniqueNumber, TaskType.NORMAL, runnables);
		then(parallelTask);
		return parallelTask;
	}
	
	/**
	 * Creates a task which will convert the output of this task to a collection, which is populated by multiple functions accepting output of this task.
	 * An {@link ParallelReturningTask} object will be created to have these transformations done in parallel.
	 * @param taskType Task type Slow or Normal
	 * @param functions Functions to be applied on the output of this task
	 * @param <R> return type of functions
	 * @return Parallel Returning task
	 */
	public <R> ParallelReturningTask<R> thenConvertToListFromDifferentTransformations(TaskType taskType, Function<T,R>... functions) {
		AtomicBoolean retrieved = new AtomicBoolean(false);
		AtomicReference<T> data = new AtomicReference<>(null);
		Supplier<R>[] suppliers = new Supplier[functions.length];
		for (int i=0;i<functions.length; i++) {
			Function<T,R> function = functions[i];
			suppliers[i] = ()-> {
					if (!retrieved.get()) {
						synchronized (retrieved) {
							if (!retrieved.get()) {	
								T val = this.get();
								data.set(val);
								retrieved.set(true);
							}
						}
					}
					return function.apply(data.get());
			};
		}
		ParallelReturningTask<R> parallelTask = ParallelReturningTask.getFromPool(this.uniqueNumber, taskType, suppliers);
		then(parallelTask);
		return parallelTask;
	}
	
	/**
	 * Creates next task which will consume the value generated by this task.
	 * @param consumer Consumer of the type this task will generate
	 * @param tp Task type
	 * @return Executable task which will run the consumer
	 */
	protected ExecutableTask thenConsume(Consumer<T> consumer, TaskType tp) {
		ExecutableTask t = getConsumeExecutableTask(consumer, tp);
		then(t);
		return t;
	}

	/**
	 * Creates an executable task which will run the consumer post retrieving data from current thread.
	 * @param consumer Consumer
	 * @param tp Task type
	 * @return Executable task
	 */
	protected ExecutableTask getConsumeExecutableTask(Consumer<T> consumer,
			TaskType tp) {
		ExecutableTask t = ExecutableTask.getFromPool(uniqueNumber,()->{
			T t2 = this.get();
			consumer.accept(t2);
		}, tp);
		return t;
	}
	
	/**
	 * /**
	 * Creates next task which will consume the value generated by this task.
	 * This task will be treated as slow task.
	 * @param consumer Consumer of the type this task will generate
	 * @return Executable task which will run the consumer
	 */
	public ExecutableTask thenConsumeSlow(Consumer<T> consumer) {
		return thenConsume(consumer, TaskType.SLOW);
	}
	
	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @param <R> type of returning task
	 * @return Returning task
	 */
	public <R> ReturningTask<R> then(Function<T,R> consumer) {
		return then(consumer, TaskType.NORMAL);
	}

	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @param tp Task type
	 * @param <R> type of returning task
	 * @return Returning task
	 */
	protected <R> ReturningTask then(Function<T, R> consumer, TaskType tp) {
		ReturningTask outputTask= ReturningTask.getFromPool(uniqueNumber,()->consumer.apply(this.get()), tp);
		super.then(outputTask);
		return outputTask;
	}
	
	
	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * This new task will be a slow task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @param <R> type of returning task
	 * @return Returning task
	 */
	public <R> ReturningTask<R> thenSlow(Function<T,R> consumer) {
		return then(consumer, TaskType.SLOW);
	}

	/**
	 * Execute the supplier and save it to output to be consumed by next task.
	 */
	@Override
	protected void executeCurrentTask() throws Throwable {
		this.output = this.supplier.get();
	}
	
	/**
	 * Get the output of current task. 
	 * This will run mostly by next task.
	 * @return Output of current task
	 */
	public T get() {
		addBackToPool();
		return output;
	}
	
	protected ReturningTask<T> updateOutput(T data) {
		this.output = data;
		return this;
	}

}
