package org.ak.trafficController;

import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import org.ak.trafficController.pool.ObjectPoolManager;

/**
 * Returning task which will run and return some value which can be picked by next task.
 * @author amit.khosla
 *
 * @param <T>
 */
public class ReturningTask<T> extends Task {

	static <K> ReturningTask<K> getFromPool(int unique, SupplierWhichCanThrowException<K> supplier, TaskType taskType) {
		ReturningTask<K> et = ObjectPoolManager.getInstance().getFromPool(ReturningTask.class, ()->new ReturningTask<K>(unique, supplier, taskType));
		et.uniqueNumber = unique;
		et.supplier = supplier;
		et.taskType = taskType;
		et.startingTask = et;
		return et;
	}
	
	@Override
	public boolean canSendBackToPool() {
		return false;
	}
	
	private SupplierWhichCanThrowException<T> supplier;
	private T output;

	/**
	 * Returning task constructor.
	 * @param unique Unique id
	 * @param supplier Supplier
	 * @param taskType Task type
	 */
	public ReturningTask(int unique, SupplierWhichCanThrowException<T> supplier, TaskType taskType) {
		super(unique, taskType);
		this.supplier = supplier;
	}
	
	/**
	 * Creates next task which will consume the value generated by this task.
	 * @param consumer Consumer of the type this task will generate
	 * @return Executable task which will run the consumer
	 */
	public ExecutableTask thenConsume(Consumer<T> consumer) {
		ExecutableTask t = thenConsume(consumer, TaskType.NORMAL);
		return t;
	}
	
	/**
	 * Creates a task which will work on the output generated by this task and have multiple consumers work in parallel
	 * @param consumers Consumer which will work on this data in parallel
	 * @return ParallelExecutingTask
	 */
	public ParallelExecutingTask thenConsumeMultiple(Consumer<T>... consumers) {
		AtomicBoolean retrieved = new AtomicBoolean(false);
		AtomicReference<T> data = new AtomicReference<>(null);
		RunnableToBeExecuted[] runnables = new RunnableToBeExecuted[consumers.length];
		for (int i=0;i<consumers.length; i++) {
			Consumer<T> consumer = consumers[i];
			runnables[i] = ()-> {
					if (!retrieved.get()) {
						synchronized (retrieved) {
							if (!retrieved.get()) {	
								T val = this.get();
								data.set(val);
								retrieved.set(true);
							}
						}
					}
					consumer.accept(data.get());
			};
		}
		ParallelExecutingTask<T> parallelTask = ParallelExecutingTask.getFromPool(this.uniqueNumber, TaskType.NORMAL, runnables);
		then(parentTask);
		return parallelTask;
	}
	/**
	 * Creates next task which will consume the value generated by this task.
	 * @param consumer Consumer of the type this task will generate
	 * @param tp Task type
	 * @return Executable task which will run the consumer
	 */
	protected ExecutableTask thenConsume(Consumer<T> consumer, TaskType tp) {
		ExecutableTask t = getConsumeExecutableTask(consumer, tp);
		then(t);
		return t;
	}

	/**
	 * Creates an executable task which will run the consumer post retrieving data from current thread.
	 * @param consumer Consumer
	 * @param tp Task type
	 * @return Executable task
	 */
	protected ExecutableTask getConsumeExecutableTask(Consumer<T> consumer,
			TaskType tp) {
		ExecutableTask t = ExecutableTask.getFromPool(uniqueNumber,()->{
			T t2 = this.get();
			consumer.accept(t2);
		}, tp);
		return t;
	}
	
	/**
	 * /**
	 * Creates next task which will consume the value generated by this task.
	 * This task will be treated as slow task.
	 * @param consumer Consumer of the type this task will generate
	 * @return Executable task which will run the consumer
	 */
	public ExecutableTask thenConsumeSlow(Consumer<T> consumer) {
		return thenConsume(consumer, TaskType.SLOW);
	}
	
	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @return Returning task
	 */
	public <R> ReturningTask<R> then(Function<T,R> consumer) {
		return then(consumer, TaskType.NORMAL);
	}

	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @param tp Task type
	 * @return Returning task
	 */
	protected <R> ReturningTask then(Function<T, R> consumer, TaskType tp) {
		ReturningTask outputTask= ReturningTask.getFromPool(uniqueNumber,()->consumer.apply(this.get()), tp);
		super.then(outputTask);
		return outputTask;
	}
	
	
	/**
	 * This method will create another Returning task which will work on the data generated by this task.
	 * This new task will be a slow task.
	 * @param consumer Consumer function consuming and transforming output of current task
	 * @return Returning task
	 */
	public <R> ReturningTask<R> thenSlow(Function<T,R> consumer) {
		return then(consumer, TaskType.SLOW);
	}

	/**
	 * Execute the supplier and save it to output to be consumed by next task.
	 */
	@Override
	protected void executeCurrentTask() throws Throwable {
		this.output = this.supplier.get();
	}
	
	/**
	 * Get the output of current task. 
	 * This will run mostly by next task.
	 * @return Output of current task
	 */
	public T get() {
		addBackToPool();
		return output;
	}

}
