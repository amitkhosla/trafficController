package org.ak.trafficController;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.ak.trafficController.pool.ObjectPoolManager;

/**
 * This class run different tasks which return some value and store it in list which can be further used by joiner etc.
 * @author amit.khosla
 *
 * @param <T> Type of data it contains
 */
public class ParallelReturningTask<T> extends ParallelTask<T> {

	static Logger logger = Logger.getLogger(ParallelReturningTask.class.getName());
	/**
	 * Create or find from pool a parallel returning task and set params.
	 * @param unique unique id
	 * @param taskType task type
	 * @param suppliers supplier
	 * @param <K> Supplier type
	 * @return
	 */
	static <K> ParallelReturningTask<K> getFromPool(int unique, TaskType taskType, Supplier<K>... suppliers) {
		ParallelReturningTask<K> et = getPoolManager().getFromPool(ParallelReturningTask.class, ()->new ParallelReturningTask<K>(unique,taskType));
//		System.out.println("retrieved from pool...." + et.hashCode());
		et.uniqueNumber = unique;
		et.tasks.clear();
		if (taskType == TaskType.NORMAL) et.addSuppliers(suppliers);
		try {
		if (taskType == TaskType.SLOW) et.addSlowSuppliers(suppliers);
		} catch (RuntimeException e) {
			logger.log(Level.WARNING, "exception occured for " + unique, e);
			throw e;
		}
		et.taskType = taskType;
		et.startingTask = et;
		return et;
	}

	/**
	 * This queue is used to store different output of different suppliers.
	 */
	protected ConcurrentLinkedQueue<T> clq = ObjectPoolManager.getInstance().
			getFromPool(ConcurrentLinkedQueue.class, ConcurrentLinkedQueue<T>::new);
	
	/**
	 * This method allows further addition of suppliers.
	 * @param suppliers Suppliers to be added
	 */
	public void addSuppliers(Supplier<T>... suppliers) {
		for (Supplier<T> supplier: suppliers) {
			tasks.add(ReturningTask.getFromPool(this.uniqueNumber,()->executeSupplier(supplier), TaskType.NORMAL));
		}
	}

	/**
	 * This method is responsible of processing the supplier, add output in queue and run post run tasks like cleanup.
	 * This method is helper method to create a task.
	 * @param supplier Supplier to be executed
	 * @return Output of supplier
	 */
	protected T executeSupplier(Supplier<T> supplier) {
		T output = supplier.get();
		clq.add(output);
		postTaskRun();
		return output;
	}
	
	/**
	 * This method allows further addition of suppliers as slow tasks.
	 * @param suppliers Suppliers
	 */
	public void addSlowSuppliers(Supplier<T>... suppliers) {
		ReturningTask<T> taskFromPool;
		for (Supplier<T> supplier: suppliers) {
			try {
				taskFromPool = ReturningTask.getFromPool(uniqueNumber, ()->executeSupplier(supplier), TaskType.SLOW);
			} catch (RuntimeException re) {
				logger.log(Level.WARNING, "Exception for " + uniqueNumber, re);
				throw (re);
			}
			tasks.add(taskFromPool);
		}
	}

	
	/**
	 * Constructor of Parallel Returning task.
	 * @param uniqueId Unique id
	 * @param taskType Task type
	 * @param suppliers Suppliers
	 */
	public ParallelReturningTask(int uniqueId, TaskType taskType, Supplier<T>... suppliers) {
		super(uniqueId,taskType);
		addSuppliers(suppliers);
	}
	
	/**
	 * This method is used to join the the result and create next task which will transform the list to required type using the provided function.
	 * @param merger Merging function
	 * @param <K> type of new returning task
	 * @return Returning task
	 */
	public <K> ReturningTask<K> join(Function<List<T>,K> merger) {
		ReturningTask<K> returningTask = ReturningTask.getFromPool(uniqueNumber,()->{
			List<T> list = get();
			K op =  merger.apply(list);
			return op;
		}, TaskType.NORMAL);
		then(returningTask);
		return returningTask;
	}

	/**
	 * Get the value generated by different suppliers.
	 * This method also performs cleanup activities.
	 * This method will normally be called by next task to retrieve values.
	 * @return Get the list of outputs
	 */
	public List<T> get() {
		List<T> list = new ArrayList<T>(this.clq);
		clq.clear();
		addBackToPool();
		return list;
	}

	public static ObjectPoolManager getPoolManager() {
		return ObjectPoolManager.getInstance();
	}
	
	/**
	 * This method is used to join the result and create next task which will transform the list to required type using the provided function.
	 * This will run the joiner as slow task.
	 * @param merger Merging function
	 * @param <K> type of new returning task
	 * @return Returning task
	 */
	public <K> ReturningTask<K> joinSlow(Function<List<T>,K> merger) {
		ReturningTask<K> returningTask = ReturningTask.getFromPool(uniqueNumber,()->{
			List<T> list = get();
			return merger.apply(list);
		}, TaskType.SLOW);
		then(returningTask);
		return returningTask;
	}
	
	/**
	 * This method is used to join the result and create a task which will consume this result. Result will be passed as List.
	 * @param merger Merger consumer
	 * @return Executable task which will run the merger
	 */
	public ExecutableTask join(Consumer<List<T>> merger) {
		return join(merger, TaskType.NORMAL);
	}

	/**
	 * This method is used to join the result and create a task which will consume this result. Result will be passed as List.
	 * @param merger Merger consumer
	 * @param taskType Task type
	 * @return Executable task which will run the merger
	 */
	protected ExecutableTask join(Consumer<List<T>> merger, TaskType taskType) {
		ExecutableTask returningTask = getJoiningTask(merger, taskType);
		then(returningTask);
		return returningTask;
	}

	/**
	 * This method is used to join the result and create a task which will consume this result. Result will be passed as List.
	 * @param merger Merger consumer
	 * @param taskType Task type
	 * @return Executable task which will run the merger
	 */
	protected ExecutableTask getJoiningTask(Consumer<List<T>> merger, TaskType taskType) {
		return ExecutableTask.getFromPool(uniqueNumber,()->{
			List<T> list = get();
			merger.accept(list);
		}, taskType);
	}
	
	/**
	 * This method is used to join the result and create a task which will consume this result. Result will be passed as List.
	 * This will run merger as slow task.
	 * @param merger Merger consumer
	 * @return Executable task which will run the merger
	 */
	public ExecutableTask joinSlow(Consumer<List<T>> merger) {
		return join(merger, TaskType.SLOW);
	}
	
	@Override
	public boolean canSendBackToPool() {
		return false;
	}
}
